#!/bin/bash

export EFIMIRROR_CONFIG_DIR="@config_path@"
export EFIMIRROR_CONFIG_PATH="${EFIMIRROR_CONFIG_DIR}/config"
export EFIMIRROR_PART_CONFIG_PATH="${EFIMIRROR_CONFIG_DIR}/partitions"

UEFI_PART_TYPE="c12a7328-f81f-11d2-ba4b-00a0c93ec93b"
UUID_PATTERN='^[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}$'

find_system_efi_partitions() {
  local line props found=0 pt

  # In early boot, lsblk can return empty tags, so we can't use it directly :(
  # Grab initial list of candidates from blkid first

  blkid -g || :

  local -a vfat_devs
  if ! readarray -t vfat_devs < <(blkid -t TYPE=vfat -s DEVNAME -o value); then
    return 1
  fi

  # Then actually pass them to lsblk and hope it does the right thing
  while read -r line; do
    # lsblk output is properly shell quoted
    declare -a "props=($line)" || continue
    declare "${props[@]}" || continue
    pt="${PARTTYPE:-}"
    [ "${pt,,}" = "$UEFI_PART_TYPE" ] || continue
    [ -n "${PARTUUID:-}" ] || continue
    echo "$PARTUUID"
    found=1
  done < <(lsblk -o PARTTYPE,PARTUUID --pairs --shell "${vfat_devs[@]}")

  if [ $found != 1 ]; then
    return 1
  fi
  return 0
}

get_configured_efi_partitions() {
  local line partuuid
  if ! [ -f "${EFIMIRROR_PART_CONFIG_PATH}" ]; then
    return 1
  fi

  local ret=1
  while read -r line; do
    if [[ "$line" =~ ^\# ]]; then
      continue
    elif [[ "$line" =~ $UUID_PATTERN ]]; then
      ret=0
      echo "$line"
    fi
  done < "$EFIMIRROR_PART_CONFIG_PATH"

  return "$ret"
}

intersect_arrays() {
  local __a="$1[*]" __b="$2[*]"
  comm -12 <(IFS=$'\n'; echo "${!__a}") <(IFS=$'\n'; echo "${!__b}")
}

get_efi_partitions() {
  local -a system_efi_partitions user_efi_partitions existing_partitions

  # The current EFI partition is always included. Then, we include all enrolled partitions
  # that we find exist

  readarray -t system_efi_partitions < <(find_system_efi_partitions | sort -u)
  readarray -t user_efi_partitions < <(get_configured_efi_partitions | sort -u)
  readarray -t existing_partitions < <(intersect_arrays system_efi_partitions user_efi_partitions)

  : "${#system_efi_partitions[@]}" "${#user_efi_partitions[@]}" # satisfy shellcheck

  sort -u < <(IFS=$'\n'; echo "${existing_partitions[*]}")
}

efibootmgr_parse_dev_partuuid() {
  if [[ "$1" =~ HD\([0-9]+,GPT,([[:xdigit:]-]+),.*\) ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

efibootmgr_get_bootnum() {
  while read -r line; do
    if [[ "$line" =~ ^Boot"$1"'*'? ]]; then
      echo "$line"
      return 0
    fi
  done
  return 1
}

systemd_bootloader_vendor_id='4a67b082-0a4c-41cf-b6c7-440b29bb8c4f'
systemd_bootloader_efivar_name="LoaderDevicePartUUID-${systemd_bootloader_vendor_id}"

systemd_get_bootloader_partuuid() {
  local efivar_path="/sys/firwmare/efi/efivars/${systemd_bootloader_efivar_name}"
  local partuuid
  if [ -e "$efivar_path" ]; then
    partuuid=$(head -c-1  "$efivar_path" | iconv -f utf16 -t utf8)
    if [ -e "/dev/disk/by-partuuid/${partuuid}" ]; then
      echo "$partuuid"
      return 0
    fi
  fi

  return 1
}

efibootmgr_get_primary_boot_devs_partuuids() {
  local efibootmgr_out
  efibootmgr_out=$(efibootmgr)

  local partuuid
  if partuuid=$(systemd_get_bootloader_partuuid); then
    echo "$partuuid"
    return 0
  fi

  local line boot_current='' boot_default=''
  while read -r line; do
    if [ -z "$boot_current" ]; then
      if [[ "$line" =~ BootCurrent:[[:blank:]]([0-9]+) ]]; then
        boot_current="${BASH_REMATCH[1]}"
      fi
      continue
    fi

    if [ -z "$boot_default" ]; then
      if [[ "$line" =~ BootOrder:[[:blank:]]([0-9]+) ]]; then
        boot_default="${BASH_REMATCH[1]}"
        break
      fi
      continue
    fi
  done <<< "$efibootmgr_out"

  local boot_info
  if [ -n "$boot_current" ]; then
    if boot_info=$(efibootmgr_get_bootnum "$boot_current" <<< "$efibootmgr_out"); then
      partuuid=$(efibootmgr_parse_dev_partuuid "$boot_info")
      print "Primary EFI partition (from BootCurrent): ${partuuid}"
      echo "$partuuid"
    fi
  fi

  if [[ -n "$boot_default" ]]; then
    if boot_info=$(efibootmgr_get_bootnum "$boot_default" <<< "$efibootmgr_out"); then
      partuuid=$(efibootmgr_parse_dev_partuuid "$boot_info")
      print "Primary EFI partition (from BootOrder): ${partuuid}"
      echo "$partuuid"
    fi
  fi
}

print() {
  # Generators need to write to kmsg
  if [ "${SYSTEMD_SCOPE:-}" = system ]; then
    echo "@generator_exe_name@:" "$@" >> /dev/kmsg
  else
    echo "$@" >&2
  fi
}

get_primary_efi_partition() {
  local -a efi_partitions=("$@")
  local partuuid

  for partuuid in "${efi_partitions[@]}"; do
    print "EFI partition: $partuuid"
  done

  local -a candidate_partuuids
  local primary_partuuid

  readarray -t candidate_partuuids < <(efibootmgr_get_primary_boot_devs_partuuids)
  for partuuid in "${candidate_partuuids[@]}"; do
    if [[ "${efi_partitions[*]}" == *"$partuuid"* ]]; then
      primary_partuuid="$partuuid"
      break
    fi

    print "Warning: candidate primary EFI partition ${partuuid} not enrolled or unavailable"
  done

  if [ -z "$primary_partuuid" ]; then
    print "Warning: no EFI partitions from boot data available, picking first of available partitions"
    primary_partuuid="${efi_partitions[0]}"
  fi

  print "Primary EFI partition: $primary_partuuid"
  echo "$primary_partuuid"
}
